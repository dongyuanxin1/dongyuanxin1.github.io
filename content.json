{"pages":[],"posts":[{"title":"前端系列汇总","text":"CSS 精选 CSS3 盒模型：border-box Flex 快速上手 你了解 css3 的 nth-child 吗 scss：最常见的 css 预处理器 scss 实现样式复用: 继承、占位符、混合宏","link":"/frontend/"},{"title":"算法系列汇总","text":"《剑指 Offer》 JavaScript 版讲解 二维数组中的查找 替换空格 从尾到头打印链表 重建二叉树 用两个栈(队列)实现队列(栈) 旋转数组的最小数字 斐波那契数列 青蛙跳台阶 变态跳台阶 矩阵覆盖 二进制中 1 的个数 数值的整次方(四种解法) 调整数组顺序使奇数位于偶数前面","link":"/algorithm/"},{"title":"CSS3盒模型：border-box","text":"box-sizing可以声明计算元素高宽的 CSS 盒模型。它有content-box、border-box和inherit三种取值。其中border-box是 css3 新增，也是主流 UI 框架的全局默认属性。 两种盒模型content-box默认值，也是 css2.1 中的盒子模型。在计算width和height时候，不计算border、padding和margin。高度、宽度都只是内容高度。 border-boxcss3新增。 width和height属性包括内容，内边距和边框，但不包括外边距。 它的计算公式是： width = border + padding + 内容宽度 height = border + padding + 内容高度 为什么不计算margin从上面可以知道，即时是border-box也是不计算margin，只是多余计算了border和padding。因为border和padding都是盒子模型的一部分，但是margin标记的是盒子和盒子的间距。所以，border-box的计算方法更符合box-sizing的语义。 问题来了，如果有时候一定要设置margin，怎么做到自由控制来保证兼容？例如，我们下面要设置一个撑满页面的盒子元素，而且有外边距干扰，怎么做？ 实际应用根据项目中的使用经验和 w3c 的建议，推荐box-sizing属性设置为border-box。在样式表文件中添加以下代码： 1234567* { margin: 0; padding: 0;}div { box-sizing: border-box;} 除了通用代码，border-box还可以配合 css3 中的四则运算符calc来使用，来实现对 margin 的控制。 代码如下： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;yuanxin.me&lt;/title&gt; &lt;style type=\"text/css\"&gt; * { margin: 0; padding: 0; } #app { box-sizing: border-box; /* 指定计算方式 */ margin: 10px; /* 外边距 */ /* 利用 css3 的 calc */ width: calc(100vw - 2 * 10px); height: calc(100vh - 2 * 10px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2018-06-05-border-sizing/"},{"title":"你了解css3的nth-child吗","text":":nth-child(n) 选择器匹配属于其父元素的第 n 个子元素，借助这个特性，可以实现选择第偶数次序的子元素、选择一定范围内的子元素等“批量选择操作”。 而它比较难理解的地方是参数表达式中n的含义，以及如何进行数学运算，这也是面试中考察的难点。 nth-child 介绍:nth-child(n) 选择器匹配属于其父元素的第 n 个子元素。 使用它的时候需要注意几点： 第 n 个子元素的计数是从 1 开始，不是从 0 开始的 选择表达式中的字母n代表 ≥0 的整数 基本操作它有 3 种常见用法： 直接指明 n 的值：span:nth-child(1) 用even/odd分别代表偶数 / 奇数：span:nth-child(even) 借助n自定义选择范围： nth-child(2n)/nth-child(2n + 1)：偶数 / 奇数 nth-child(n + 3)：第 3 个开始到最后 骚操作：限制选择范围上面的用法中的第三部分，一般都是使用n，而有时候也会用到-n，比如选取前 2 个元素就是：nth-child(-n + 2)。 为什么是这样呢？其实运算：-n + 2 ≥ 0，就可以推出n ≤ 2。 由此，结合两者自动取交集，我们就可以限制选择某一范围。比如选择第 6 个到第 9 个，就是：:nth-child(-n+9):nth-child(n+6) 注意：不是nth-child(2 - n)，-n要写在一起！ 子元素 !== 后代元素请思考下面这段代码的样式效果（1是黑色的，2和3都是红色的） 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;style&gt; span:nth-child(2n) { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt; &lt;span&gt;3&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 因为&lt;span&gt;2&lt;/span&gt;是其父节点的第 2 个（偶数）子元素。&lt;span&gt;3&lt;/span&gt;是其父节点的第 2 个子元素，第一个是&lt;div&gt;&lt;/div&gt;。 所以在借助nth-child匹配子元素时，要看清楚 DOM 树的层级关系。","link":"/2019-03-19-css3-nth-child/"},{"title":"Flex快速上手","text":"Flex之于 CSS3 就如Promise之于 ES6，都解决了开发者的痛点问题，大大提高了生产力。借助Flex，可以轻松实现栅栏布局、水平/垂直居中、自定义排列方向和顺序等等需求。 前端工程师的福音：flex原来写前端的过程中，得有一大部分的时间是花费在了水平/垂直居中对齐这件事情上，而网上也是一大堆试图解释某一种对齐方法是正确的文章，搞得头昏脑胀。 终于，弹性布局flex来了，现在团队的开发，在布局上都采用了flex，毕竟不要把生命浪费在对齐这件事情上。 容器的属性和常用值容器可以通过设置display属性为flex / inline-flex（行内 flex）来指定其为 flex 布局。 下面，将记录一下容器的属性和常用值，基本可以囊括大多数应用场景。 属性 含义 值 常用值 flex-direction 项目排列方向 row(默认)、row-reverse、column、column-reverse row / column flex-wrap 项目是否换行 nowrap(默认)、wrap、wrap-reverse wrap（允许换行） justify-content 水平对齐方向 flex-start(默认)、flex-end、center、space-between、space-around center(水平居中)/ space-around(等间距布局) align-items 垂直对齐方向 flex-start、flex-end、center、baseline、stretch(默认: 占满整个容器的高度) center(垂直居中) 项目的属性和常用值首先来看下项目元素上常用的 2 个属性，order和flex-grow： 属性 含义 值 常用值 order 项目本身的排列顺序 整数，默认为 0。越小越靠前 整数 flex-grow 项目的放大比例 ≥0 的整数，默认为 0 1 其中，order很好理解，下面通过一个例子来展示flex-grow属性的妙用： 12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;style&gt; div { display: flex; } span:nth-child(1) { flex-grow: 1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 可以在浏览器中看到，第一个&lt;span&gt;标签由于设置了flex-grow: 1，它自动占据了父容器除了剩下两个&lt;span&gt;标签外的所有空间！ 常见应用场景场景 ①：水平垂直居中 以上面的html结构为例，如果要让&lt;div&gt;中的元素水平垂直居中，只需要以下样式代码： 12345div { display: flex; justify-content: center; align-items: center;} 场景 ②：左右两侧布局，其中一侧宽度确定；另一侧宽度占满剩余空间，并且自动响应 我们要做的就是将自动响应的那一侧的元素的flex-grow属性设置为 1 即可。 场景 ③：栅栏布局系统 还是以上面的html结构为例，实现一个将屏幕等分为 12 列，3 个&lt;span&gt;标签分别占据屏幕宽度的：1/6、1/6 和 2/3。 123456789span:nth-child(1) { flex: 2;}span:nth-child(2) { flex: 2;}span:nth-child(3) { flex: 8;} 和原来相比，flex实现的栅栏布局优点有两个： 不再局限于 12 列 不再需要计算宽度，也不需考虑宽度浮点数带来的误差 必看：flex 的坑在实现水平垂直居中的过程中，发现了flex布局仅仅影响容器的一级子元素。例如下面这段代码： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;style&gt; .level1 { display: flex; align-items: center; justify-content: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"level1\"&gt; &lt;div class=\"level2\"&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; level2 类就不是水平垂直居中的，因为水平垂直居中仅仅影响到了level2，而不会进一步向下”污染“更深级别的子元素的布局样式。 如果要让 level2 也实现水平垂直居中，我们可以专门封装一个用于水平垂直居中的类，代码如下： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;style&gt; .center { display: flex; align-items: center; justify-content: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"level1 center\"&gt; &lt;div class=\"level2 center\"&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 参考链接 阮一峰的网络日志 Flex 布局教程：语法篇 菜鸟教程 Flex 布局语法教程","link":"/2019-03-20-css3-flex/"},{"title":"scss：最常见的css预处理器","text":"Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass。 他们都是用Ruby开发 Css 预处理器，boostrap4已经将less换成了scss。 SCSS和SassSass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass。他们都是用Ruby开发 Css 预处理器，boostrap4已经将less换成了sass。 不同之处： 文件拓展名：分别是sass和scss 缩进：sass严格缩进（类似 python 和 ruby），scss是 css 的缩进样式 是否兼容 css 语法：显然，由于缩进的不同，scss是兼容原生的 css 写法。 总的来说，scss是sass升级版，兼容 css 语法，并且有着自己的独立语法。 环境配置 安装 ruby：windows 注意添加注册表路径 安装 sass：利用 ruby 的包管理器gem安装，命令行运行:gem install sass 升级和删除 sass：gem update/uninstall sass 如果国外源过慢？ 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l #查看是不是淘宝源 编译编译指的是：将 scss 文件编译为 css 文件的过程。 源文件编译单文件编译 12# 格式：sass 待编译的Sass文件名:编译后CSS文件名scss scss.scss:css.css 实时自动编译 使用--watch参数即可，scss 会在源文件改动时候，自动重新编译。 1scss --watch scss.scss:css.css # 方便 输出文件风格命令行编译时候，使用--style参数。 一段 scss 代码： 12345body { h1 { color: red; }} 默认：嵌套输出方式 nested 123body h1 { color: red;} 展开输出方式 expanded 123body h1 { color: red;} 紧凑输出方式 compact 123body h1 { color: red;} 压缩输出方式 compressed 123body h1 { color: red;} 4. 注意 最新的 scss 开启了sourcemap功能，--sourcemap参数默认添加。","link":"/2018-05-29-scss-fisrt-step/"},{"title":"scss实现样式复用: 继承、占位符、混合宏","text":"如何让 scss 代码可复用？三种复用方式分别用在何处？下方是一段自定义大小的样例 👇 1234567891011121314151617$height: 15px !default;$width: 18px !default;@mixin size($list...) { @if length($list) == 0 { height: $height; width: $width; } @else if length($list) == 1 { height: $list; width: $list; } @else if length($list) == 2 { height: nth($list, 1); width: nth($list, 2); } @else { @debug \"Too many parameters\"; }} (本文使用的是： scss v3.5.6 和 ruby v2.4.4) 继承在 scss 中，一个样式类，可以被其他样式类直接继承，从而减少重复代码的编写。 例如，在 css 中，代码如下： 12345678910111213.btn,.btn--primary,.btn--info { border: 1px solid blue;}.btn--primary { color: black;}.btn--info { color: gray;} 在 scss 中，代码如下： 12345678910111213.btn { border: 1px solid blue;}.btn--primary { color: black; @extend .btn;}.btn--info { color: gray; @extend .btn;} 对比 css 的代码，编写出的 scss 代码语义更强：.btn是基础样式类，.btn--primary和.btn--info是扩展样式类。 占位符顾名思义，如果不被引用，它是不会被编译到 css 文件中的。这是和继承最大区别。 scss 代码如下： 12345678910111213141516171819%btn { border: 1px solid blue;}// 没有被extend// 不会出现在css文件中%test-btn { border: 1px solid black;}.btn--primary { color: black; @extend %btn;}.btn--info { color: gray; @extend %btn;} 编译后的 css 代码，并没有占位符%test-btn的样式代码。编译后的 css 如下： 123456789101112.btn--primary,.btn--info { border: 1px solid blue;}.btn--primary { color: black;}.btn--info { color: gray;} 混合宏它是 scss 中的函数，通过关键字@mixin声明，@include引用。 无参调用scss： 12345678@mixin btn { border-radius: 3px;}.box { color: white; @include btn;} 编译后的 css： 1234.box { color: white; border-radius: 3px;} 参数调用scss: 1234567891011$radius: 3px !default;@mixin btn($radius: 5px) { // 默认是 5px border-radius: $radius;}.box { color: white; @include btn($radius); // 传入参数} 编译后的 css： 1234.box { color: white; border-radius: 3px;} ...参数运算符scss: 1234567891011121314151617181920212223242526272829303132333435363738$height: 15px !default;$width: 18px !default;@mixin size($list...) { @if length($list) == 0 { height: $height; width: $width; } @else if length($list) == 1 { height: $list; width: $list; } @else if length($list) == 2 { height: nth($list, 1); width: nth($list, 2); } @else { @debug \"Too many parameters\"; }}.btn--primary { @include size();}.btn--big { @include size(20px, 25px);}.btn--square { @include size(18px);}.btn--test { @include size( 1px, 2px, 3px, 4px ); // just a test. console output \"Too many parameters\" what we have defined.} 编译后的 css： 1234567891011121314.btn--primary { height: 15px; width: 18px;}.btn--big { height: 20px; width: 25px;}.btn--square { height: 18px; width: 18px;} 优缺点优点是可以传递参数，更加灵活。缺点是编译后的 css 代码可能存在“冗赘”，例如下方代码： 12345678910111213@mixin border-radius { -webkit-border-radius: 3px; border-radius: 3px;}.box { @include border-radius; margin-bottom: 5px;}.btn { @include border-radius;} 在这种灵活性不高的场景下，“占位符”是更好的选择。 思考：编程语言特性 &amp; 预处理除了文中所述的 3 种样式复用的手段，scss 更引入了变量声明、循环、条件判断、函数（混合宏）、模块等编程语言才有的概念，使得开发者在编写样式代码的时候也可以编写复杂逻辑。 但 scss 本身还是预处理器（浏览器无法直接解析），一段短小精悍的代码，经过预处理后的 css 代码可能非常庞大。比如在 scss 中编写经典的“24 栅栏布局”代码，一个从 0-23 的循环即可，寥寥几行。但是最终生成的 css 一行都不会少。 因此，不光要利用 scss 的编程语言特性来简化样式代码，还要考虑编译后的 css 文件的大小。毕竟网络传输开销辣么大！","link":"/2018-05-29-scss-more/"},{"title":"剑指offer - 二维数组中的查找 - JavaScript","text":"题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法 1：暴力法遍历数组中的所有元素，找到是否存在。 时间复杂度是 O(N^2)，空间复杂度是 O(1) 12345678910111213141516171819202122// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; for (let i = 0; i &lt; rowNum; i++) { for (let j = 0; j &lt; colNum; j++) { if (array[i][j] === target) return true; } } return false;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：观察数组规律按照题目要求，数组的特点是：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。考虑以下数组： 1231 2 34 5 67 8 9 在其中寻找 5 是否存在。过程如下： 从右上角开始遍历 当前元素小于目标元素(3 &lt; 5)，根据数组特点，当前行中最大元素也小于目标元素，因此进入下一行 当前元素大于目标元素(6 &gt; 5)，根据数组特点，行数不变，尝试向前一列查找 找到 5 代码如下： 1234567891011121314151617181920212223242526272829303132// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; if (!colNum) { return false; } let row = 0, col = colNum - 1; while (row &lt; rowNum &amp;&amp; col &gt;= 0) { if (array[row][col] === target) { return true; } else if (array[row][col] &gt; target) { --col; } else { ++row; } } return false;} 时间复杂度是 O(M+N)，空间复杂度是 O(1)。其中 M 和 N 分别代表行数和列数。","link":"/2019-12-19-er-wei-shu-zu-cha-zhao/"},{"title":"剑指offer - 矩阵覆盖 - JavaScript","text":"题目描述:我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题目描述我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 1: 斐波那契数列这题和“青蛙跳台阶”类似，也是斐波那契数列的变形。 假设覆盖2*n矩形有 f(n) 种方法。那么这个2*n的矩形可能由2*(n-1)和2*(n-2)的矩形直接一步变化而来。如下图所示： 因此 f(n) = f(n - 1) + f(n - 2)。 代码如下： 123456789101112131415161718192021222324252627// 原文地址：https://xxoo521.com/2019-12-30-ju-zhen-fu-gai/// ac地址：https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6/** * @param {number} number * @return {number} */function rectCover(number) { if (number === 0) { return 0; } const cache = { 0: 0, 1: 1 }; return __rectCover(number + 1); function __rectCover(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __rectCover(n - 1) + __rectCover(n - 2); return cache[n]; }} 斐波那契相关题目 斐波那契数列：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 青蛙跳台阶：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/","link":"/2019-12-30-ju-zhen-fu-gai/"},{"title":"剑指offer - 数值的整次方(四种解法) - JavaScript","text":"题目描述：给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 保证 base 和 exponent 不同时为 0 题目描述给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 保证 base 和 exponent 不同时为 0 解法 1: 内置函数第一反应直接调用库函数。 123456// 原文地址：https://xxoo521.com/2019-12-31-pow/// ac地址：https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00function Power(base, exponent) { return Math.pow(base, exponent);} 解法 2: 暴力法将数字 base 连续乘 exponent 次即可。 时间复杂度是 O(N),空间复杂度是 O(1) 1234567891011121314151617181920// 原文地址：https://xxoo521.com/2019-12-31-pow/// ac地址：https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00function Power(base, exponent) { if (exponent === 0) { return 1; } if (exponent === 1) { return base; } const isNegative = exponent &lt; 0; // 是否是负指数 const absExponent = Math.abs(exponent); let result = base; for (let i = 1; i &lt; absExponent; ++i) { result = result * base; } return isNegative ? 1 / result : result;} 解法 3: 二分法 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 为了方便讨论，假设指数exponent是正数。那么递归式如下： 如果exponent是偶数，Power(base, exponent) = Power(base, exponent / 2) * Power(base, exponent / 2) 如果exponent是奇数，Power(base, exponent) = base * Power(base, exponent / 2) * Power(base, exponent / 2) 对于负指数exponent的情况，取其绝对值先计算。将最后结果取倒数即可。 时间复杂度是 O(logN)；由于采用递归结构，空间复杂度是 O(logN)。 123456789101112131415161718192021// 原文地址：https://xxoo521.com/2019-12-31-pow/// ac地址：https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00function Power(base, exponent) { const isNegative = exponent &lt; 0; // 是否是负指数 const result = absPower(base, Math.abs(exponent)); return isNegative ? 1 / result : result;}function absPower(base, exponent) { if (exponent === 0) { return 1; } if (exponent === 1) { return base; } const subResult = absPower(base, Math.floor(exponent / 2)); return exponent % 2 ? subResult * subResult * base : subResult * subResult;} 解法 4: 位运算第 3 种解法可以转换为迭代写法。迭代写法和位运算有关。 为了理解，假设 base=3，exponent= 5。那么 5 的二进制是：101。所以，3 的 5 次方可以写成下图的格式： 可以看到，对 base 进行自乘，导致 base 的指数每次都扩大 2 倍。与 exponent 的二进制相对应。 以上图为例，整个算法的流程如下： 结果值 result 初始为 1 base 初始为 3，此时 exponent 的二进制最右位为 1，更新结果为：base * result exponent 右移一位。base 进行累乘，base 更新为 3 的 2 次方。由于 exponent 的二进制最右位为 0，不更新结果 exponent 右移一位。base 进行累乘，base 更新为 3 的 4 次方。此时 exponent 的二进制最右位为 1，更新结果为：base * result 结束 代码如下： 1234567891011121314151617181920212223242526// 原文地址：https://xxoo521.com/2019-12-31-pow/// ac地址：https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00function Power(base, exponent) { if (exponent === 0) { return 1; } if (exponent === 1) { return base; } const isNegative = exponent &lt; 0; // 是否是负指数 let absExponent = Math.abs(exponent); let result = 1; while (absExponent) { // 如果exponent最右位是1，将当前base累乘到result if (absExponent &amp; 1) { result = result * base; } base = base * base; // base自乘法 absExponent = Math.floor(absExponent / 2); // exponent右移1位 } return isNegative ? 1 / result : result;}","link":"/2019-12-31-pow/"},{"title":"剑指offer - 二进制中1的个数 - JavaScript","text":"题目描述：输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。 题目描述输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。 解法 1: 判断每一位依次判断数字的每一位，统计其中 1 的数量。整体思路如下： 数字先和 1 相与，结果为 0 说明改位是 1，结果为 1 说明该位是 1 将 1 左移一位，再和数字相与。这次判断的是倒数第二位是否位 1 将 1 总共左移 32 次（因为数字底层是 32 位），统计总数即可 注意：尽量规避让原数字右移动，有符号位的问题，可能会陷入死循环。尽量采取左移而不是右移。 时间复杂度 O(1), 空间复杂度 O(1)。代码如下： 123456789101112131415161718192021// 原文地址：https://xxoo521.com/2019-12-31-number-of-one/// ac地址：https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8/** * @param {number} n * @return {number} */function NumberOf1(n) { let count = 0; let flag = 1; let times = 0; while (times++ &lt; 32) { if (flag &amp; n) { count += 1; } flag = flag &lt;&lt; 1; } return count;} 解法 2: n &amp; (n - 1) 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2 采用n &amp; (n - 1)的做法，这种做法的可行原因是：能将数字 n 的二进制表示中，最右边的 1 变成 0。 举个例子，以 5 为例，其二进制是 101: 101 &amp; 100 =&gt; 100 100 &amp; 011 =&gt; 0 因此，整体思路是： n 和 n-1 相与的结果赋给 n n 如果为 0，结束；否则回到第 1 步 和解法 1 相比，空间复杂度是 O(1)，但是解法 1 一定需要循环 32 次，但是解法 2 的循环次数就是数字中 1 的个数，优于解法 1。 1234567891011121314151617// 原文地址：https://xxoo521.com/2019-12-31-number-of-one/// ac地址：https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8/** * @param {number} n * @return {number} */function NumberOf1(n) { let count = 0; while (n) { n = n &amp; (n - 1); ++count; } return count;}","link":"/2019-12-31-number-of-one/"},{"title":"剑指offer - 替换空格 - JavaScript","text":"题目描述: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 解法 1：正则表达式第一反应肯定正则表达式，在真正项目中，肯定也会选用正则来做匹配和替换。 123456789// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { return str.replace(/ /g, \"%20\");} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：双指针因为字符串是不可变的，所以如果直接采用从头到尾遍历原字符串检查空格，并且做替换。那么每次检查到空格后，都需要重新生成字符串。整个过程时间复杂度是 O(N^2)。 优化的关键：提前计算替换后的字符串的长度，避免每次都对字符串做改动。 整体思路如下： 遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度 准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串 i 从头开始遍历原字符串 str[i]是非空格，那么将 i 指向的字符放入新字符串的 j 位置。i 和 j 都增加 1。 str[i]是空格，那么 j 指向的位置依次填入%20。i 增加 1，j 增加 3。 时间复杂度是 O(N)。因为需要对新字符串开辟容器，空间复杂度是 O(N)。 12345678910111213141516171819202122232425262728293031323334353637// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { if (!str || !str.length) { return \"\"; } let emptyNum = 0, chNum = 0; for (let i = 0; i &lt; str.length; ++i) { if (str[i] === \" \") { ++emptyNum; } else { ++chNum; } } const length = emptyNum * 2 + chNum; const chs = new Array(length); // i 是新字符串的下标 // j 是原字符串的下标 for (let i = 0, j = 0; j &lt; str.length; ++j) { if (str[j] === \" \") { chs[i++] = \"%\"; chs[i++] = \"2\"; chs[i++] = \"0\"; } else { chs[i++] = str[j]; } } return chs.join(\"\");}","link":"/2019-12-19-ti-huan-kong-ge/"},{"title":"剑指offer - 重建二叉树 - JavaScript","text":"题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解法 1: 递归首先前序/后序遍历 + 中序遍历可以重建二叉树。题目考察的就是前序+中序来重建二叉树，后序+中序的思路是类似的。 例子与思路假设有二叉树如下： 12345 1 / \\ 2 3 / \\4 5 它的前序遍历的顺序是：1 2 4 5 3。中序遍历的顺序是：4 2 5 1 3 因为前序遍历的第一个元素就是当前二叉树的根节点。那么，这个值就可以将中序遍历分成 2 个部分。在以上面的例子，中序遍历就被分成了 4 2 5 和 3 两个部分。4 2 5就是左子树，3就是右子树。 最后，根据左右子树，继续递归即可。 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 代码实现123456789101112131415161718192021222324252627282930313233// ac地址：https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6// 原文地址：https://xxoo521.com/2019-12-21-re-construct-btree//* function TreeNode(x) { this.val = x; this.left = null; this.right = null;} *//** * @param {TreeNode} pre * @param {TreeNode} vin * @return {TreeNode} */function reConstructBinaryTree(pre, vin) { if (!pre.length || !vin.length) { return null; } const rootVal = pre[0]; const node = new TreeNode(rootVal); let i = 0; // i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数 for (; i &lt; vin.length; ++i) { if (vin[i] === rootVal) { break; } } node.left = reConstructBinaryTree(pre.slice(1, i + 1), vin.slice(0, i)); node.right = reConstructBinaryTree(pre.slice(i + 1), vin.slice(i + 1)); return node;}","link":"/2019-12-21-re-construct-btree/"},{"title":"剑指offer - 调整数组顺序使奇数位于偶数前面 - JavaScript","text":"题目描述: 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解法 1:开辟新空间(时间更优)此过程需要循环 2 次，时间复杂度 O(N), 空间复杂度 O(N)。过程如下： 第一次循环依次找到偶数和奇数，并且将其分别存放到新开辟的空间中 第二次循环将存放偶数和奇数的空间“连接”在一起 代码如下： 123456789101112131415// 原文地址：https://xxoo521.com/2020-01-01-tiao-zheng-shu-zu/// ac地址：https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593/** * @param {number[]} array * @return {number[]} */function reOrderArray(array) { const arr = []; // 奇数数组 const brr = []; // 偶数数组 array.forEach(item =&gt; { item % 2 ? arr.push(item) : brr.push(item); }); return arr.concat(brr);} 解法 2: 插入排序思路(空间更优)这种思路和插入排序相似，时间复杂度 O(N^2)，空间复杂度 O(1)，不推荐。 这里时间复杂度主要浪费在“保持偶数和奇数原相对位置不变”这个要求上。 整体的思路： 指针 i 从 0 开始向右移动，如果遇到奇数，继续移动；遇到偶数，停下来，并进入循环 设置新指针 j = i + 1，指针 j 向右移动，遇到偶数，继续移动；遇到奇数，停下来，并进入下一步 将数组[i, j - 1] 的元素整体向右位移 1 位，然后将 j 上的元素赋给 i 上的元素 检测是否遍历完成，未完成则回到第一步 123456789101112131415161718192021222324252627282930313233343536// 原文地址：https://xxoo521.com/2020-01-01-tiao-zheng-shu-zu/// ac地址：https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593/** * @param {number[]} array * @return {number[]} */function reOrderArray(array) { const length = array.length; if (!length) { return []; } let i = 0; while (i &lt; length) { if (array[i] % 2 === 0) { // 如果指针i对应的元素是偶数 // 那么就需要找到其后出现的第一个奇数 // 然后和指针i的元素进行交换 let j = i + 1; for (; j &lt; length &amp;&amp; array[j] % 2 === 0; ++j) {} if (j === length) { break; } else { // 整体右移，保证原元素的相对位置不变 const tmp = array[j]; for (let k = j; k &gt; i; k--) { array[k] = array[k - 1]; } array[i] = tmp; } } i++; } return array;} 拓展思考 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 如果题目中的要求，去掉“保证奇数和奇数，偶数和偶数之间的相对位置不变”这个条件，那么做法是什么呢？ 可以利用“双指针”，分别是指向数组头部的指针 i，与指向数组尾部的指针 j。过程如下： i 向右移动，直到遇到偶数；j 向左移动，直到遇到奇数 检查 i 是否小于 j，若小于，交换 i 和 j 的元素，回到上一步骤继续移动；否则结束循环 时间复杂度是 O(N),空间复杂度是 O(1)。代码如下： 123456789101112131415161718192021222324252627// 原文地址：https://xxoo521.com/2020-01-01-tiao-zheng-shu-zu/// ac地址：扩展思考/** * @param {number[]} array * @return {number[]} */function reOrderArray(array) { const length = array.length; if (!length) { return []; } let i = 0, j = length - 1; while (i &lt; j) { while (i &lt; length &amp;&amp; array[i] % 2) i++; while (j &gt;= 0 &amp;&amp; array[j] % 2 === 0) j--; if (i &lt; j) { [array[i], array[j]] = [array[j], array[i]]; i++; j--; } } return array;}","link":"/2020-01-01-tiao-zheng-shu-zu/"},{"title":"剑指offer - 用两个栈(队列)实现队列(栈) - JavaScript","text":"题目描述：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 拓展思考：如何用两个队列实现一个栈？ 题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 解法 1: 利用栈的特性栈的特性是：后入先出。根据题目提示，使用 2 个栈即可。一个栈inStack用来存储插入队列的数据，一个栈outStack用来从队列中取出数据。 算法分为入队和出队过程。 入队过程：将元素放入 inStack 中。 出队过程： outStack 不为空：弹出元素 outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出） 时间复杂度是 O(N)，空间复杂度是 O(N)。 12345678910111213141516171819// 原文地址：https://xxoo521.com/2019-12-23-zhan-shi-xian-dui-lie/// ac地址：https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6const inStack = [];const outStack = [];function push(node) { inStack.push(node);}function pop() { if (outStack.length) { return outStack.pop(); } else { while (inStack.length) { outStack.push(inStack.pop()); } return outStack.pop(); }} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 拓展思考：用两个队列实现一个栈类似地，用两个队列也可以实现一个栈。但由于队列是先入先出，无论怎么倒换，都不可能逆序队列。所以处理思路并不一样。 准备两个队列q1和q2。算法过程分为入栈和出栈。 入栈过程： q1 为空，放入 q2 q2 为空，放入 q1 均为空，默认放入 q1 出栈过程： q1 为空： 依次取出 q2 中的元素（除了最后一个），并且放入 q1 中 取出 q2 中的最后一个元素，返回结果 q2 为空： 依次取出 q1 中的元素（除了最后一个），并且放入 q2 中 取出 q1 中的最后一个元素，返回结果 时间复杂度是 O(N)，空间复杂度是 O(N)。","link":"/2019-12-23-zhan-shi-xian-dui-lie/"},{"title":"剑指offer - 旋转数组的最小数字 - JavaScript","text":"题目描述:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 解法 1:暴力法遍历一次，直接找到比较出最小的数字。 时间复杂度是 O(N)，空间复杂度是 O(1)。 1234567891011121314// 原文地址：https://xxoo521.com/2019-12-24-xuan-zhuan-shu-zu/// ac地址：https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba/** * @param {number[]} rotateArray */function minNumberInRotateArray(rotateArray) { const length = rotateArray.length; if (!length) { return 0; } return Math.min(...rotateArray);} 解法 2: 二分查找 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 看到这种题目，正确做法基本上都是需要使用二分查找。 对于这种变形的二分查找的考察，解决思路主要都是：观察 left、mid、right 三个指针对应的元素的大小关系，然后移动指针。 具体的解决方法主要是：多写几个例子，然后观察如何移动。 举几个例子来推导解题细节（请记住题干的数组有序、某个点旋转这两个条件）： arr[left] &lt; arr[right]: 直接返回arr[left]。例如：1 2 3 4 5 arr[left] &lt; arr[mid]: 说明从数组下标范围为[left, right]的元素是递增的，此时最小值只可能出现在[mid + 1, length)范围内。例如:4 5 1 2 3 arr[mid] &lt; arr[right]: 说明从数组下标范围为[mid, right]的元素是递增的，此时最小值只可能出现在[left, mid] 范围内。注意，这里不能跳过下标mid。例如：3 3 3 4 5 其他情况，此时arr[mid] = arr[right] = arr[left]: 移动 left，缩小范围即可。例如：1 1 1 0 1 1234567891011121314151617181920212223242526272829303132333435// 原文地址：https://xxoo521.com/2019-12-24-xuan-zhuan-shu-zu/// ac地址：https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01bafunction minNumberInRotateArray(rotateArray) { const length = rotateArray.length; if (!length) { return 0; } let left = 0, right = length - 1; while (left &lt; right) { let mid = Math.floor((left + right) / 2); // 子数组有序 if (rotateArray[left] &lt; rotateArray[right]) { return rotateArray[left]; } // 左子数组有序，最小值在右边 // 那么mid肯定不可能是最小值（因为rotateArray[mid]大于rotateArray[left]） if (rotateArray[left] &lt; rotateArray[mid]) { left = mid + 1; // 右子数组有序，最小值在左边 // 这里right=mid因为最小值可能就是rotateArray[mid] } else if (rotateArray[mid] &lt; rotateArray[right]) { right = mid; } else { // 无法判断，缩小下范围 ++left; } } return rotateArray[left];}","link":"/2019-12-24-xuan-zhuan-shu-zu/"},{"title":"剑指offer - 从尾到头打印链表 - JavaScript","text":"题目描述：输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 题目描述输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 解法 1: 栈题目要求的是从尾到头。这种“后进先出”的访问顺序，自然想到了用栈。 时间复杂度 O(N)，空间复杂度 O(N)。 123456789101112131415161718192021222324252627// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//*function ListNode(x){ this.val = x; this.next = null;}*//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } const reverse = []; while (stack.length) { reverse.push(stack.pop()); } return reverse;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 发现后半段出栈的逻辑，其实就是将数组reverse反转。因此，借助 javascript 的 api，更优雅的写法如下： 1234567891011121314151617// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } return stack.reverse();}","link":"/2019-12-21-da-yin-lian-biao/"},{"title":"剑指offer - 青蛙跳台阶 - JavaScript","text":"题目描述: 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解法 1: 斐波那契数列这题其实就是在求斐波那契数列。理解起来也很简单。假设跳到 n 级台阶有 f(n)种方法。根据题目，青蛙在跳上 n 级时有 2 种方法： 从 n - 1 级跳 1 级上来 从 n - 2 级跳 2 级上来 青蛙跳到 n- 1 级有 f(n-1)种方法，跳到 n- 2 级有 f(n-2)种方法。所以 f(n) = f(n - 1) + f(n - 2)。这就是斐波那契数列的定义式。 需要注意的是，它和斐波那契下标不是完全对应。比如跳上 2 级，有 2 种方法。所以跳上 n 级不是 f(n)，而是 f(n + 1)。 12345678910111213141516171819// 原文地址：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/// ac地址：https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4function jumpFloor(n) { const cache = { 0: 0, 1: 1 }; return __jumpFloor(n + 1); // 注意下标 function __jumpFloor(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __jumpFloor(n - 1) + __jumpFloor(n - 2); return cache[n]; }} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 更多解法关于斐波那契还有循环写法，以及备忘录模式的其他优点。具体请看：https://xxoo521.com/2019-12-25-fei-bo-na-qi/。","link":"/2019-12-26-qing-wa-tiao-tai-jie/"},{"title":"剑指offer - 斐波那契数列 - JavaScript","text":"题目描述：大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39。 题目描述大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39。 解法 1: 数学定义根据数学定义：f(n) = f(n - 1) + f(n - 2)。最初始情况是f(0) = 0和f(1) = 1。 因此直接循环更新即可。时间复杂度 O(N)，空间复杂度 O(1)。 12345678910111213141516171819202122232425// 原文地址：https://xxoo521.com/2019-12-25-fei-bo-na-qi/// ac地址：https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3/** * @param {number} n * @return {number} */function Fibonacci(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } let a = 0, b = 1; for (let i = 2; i &lt; n; ++i) { let c = a + b; a = b; b = c; } return a + b;} 解法 2: 递归 + 动态规划根据数学定义：f(n) = f(n - 1) + f(n - 2)，代码可以实现为递归形式。 但是以 f(5)为例，它的过程如下： f(5) = f(4) + f(3) f(4) = f(3) + f(2) f(3) = f(2) + f(1) …省略 注意在第 2 步和第 3 步中，我们计算了 2 次 f(3)的值。当要求的 n 越大的时候，重复计算就会越多，时间复杂度就会越高。 在动态规划的一种做法中，可以借助“备忘录”来实现结果的缓存，避免重复计算。 代码如下，时间复杂度是 O(N)，空间复杂度是 O(1)。 123456789101112131415161718192021222324252627// 原文地址：https://xxoo521.com/2019-12-25-fei-bo-na-qi/// ac地址：https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3/** * @param {number} n * @return {number} */function Fibonacci(n) { const cache = { 0: 0, 1: 1 }; return __Fibonacci(n); /** * @param {number} n * @return {number} */ function __Fibonacci(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __Fibonacci(n - 1) + __Fibonacci(n - 2); return cache[n]; }} “备忘录”的其他优点 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 虽然备忘录用了 O(N)的空间。但是重复计算同个 f(n)的结果时候，时间复杂度是 O(1)。比如之前调用过一次Fibonacci(10)，那么 f(10)的结果就缓存在了 cache 中。再次调用函数，直接从缓存读取即可。 同样地，当 n &lt; 10 时候，结果都是从 cache 中直接读取，时间复杂度均是 O(1)。 再推广，当计算 f(20)的时候，n &lt; 10 的结果都计算完了，不需要重复计算。效率是高于第一种循环写法的调用。 总结：备忘录缓存了计算结果，避免了多次调用时的重复计算。","link":"/2019-12-25-fei-bo-na-qi/"},{"title":"剑指offer - 变态跳台阶 - JavaScript","text":"题目描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 解法 1: 公式推导假设跳 n 级台阶的跳法数量是 f(n)个。 那么根据题意，青蛙可能从 n-1 级直接跳上来，也可能从 n-2 级直接跳上来，依次类推：f(n) = f(n - 1) + f(n - 2) + ... + f(1) 同理：f(n - 1) = f(n - 2) + f(n - 3) + ... + f(1) 所以，将公式 1 中的f(n - 2) + f(n - 3) + ... + f(1)替换为f(n - 1)。公式 1 变为：f(n) = f(n - 1) + f(n - 1) = f(n - 1) * 2 （公式 3） 同理：f(n - 1) = f(n - 2) + f(n - 2) = f(n - 2) * 2（公式 4） 结合公式 3 和公式 4: f(n) = f(n - 2) * 2 * 2。因此可以推出：f(n) = 2^(n - 1) 代码如下： 12345678910// 原文地址：https://xxoo521.com/2019-12-27-bian-tai-tiao-tai-jie/// ac地址：https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387/** * @param {number} number * @return {number} */function jumpFloorII(number) { return Math.pow(2, number - 1);} 相关题目 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 斐波那契数列：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 青蛙跳台阶：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 矩阵覆盖:https://xxoo521.com/2019-12-30-ju-zhen-fu-gai/","link":"/2019-12-27-bian-tai-tiao-tai-jie/"},{"title":"如何保持保持高效学习？","text":"这是我最近特别想记录的心得，关于「如何保持高效学习」。 在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 这是我最近特别想记录的心得，关于「如何保持高效学习」。 最近在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 制定任务，模拟奖励根据这几个月重新玩「神武」（一款类似梦幻西游的回合制游戏）的感触，我发现这款游戏让人上瘾的点在于：你可以通过做任务/参见活动，获得各种奖励，并且提高人物的属性面板。我天，仔细想了下这不是和自我学习有点相似？ 于是我尝试着给自己制定每周任务，像「实现 promise」、「计算机专业论文算法完成」、「数学专业完成矩阵特征值的 4 中方法编程实现」。 有了任务，怎么模拟奖励呢？游戏给我的奖励是「提高人物属性」，潜意识里就是告诉玩家“你在变强”。思路转化过来就是，模拟的奖励需要让我自己感觉我在变强：）因此模拟的奖励是： 技术面变广，技术栈变深 定期将所学输出文章，方便日后回查，也打造个人 IP 早做完毕设，早回公司，脱离无 💰 生活 番茄学习仔细玩游戏你会发现，游戏的大多数任务和活动，都是玩家 10-20 分钟之间可以完成的。如果一个任务做了 2 小时，任谁都会感觉又累又烦。在学习过程中同样如此，一个学习任务一下午，状态差的时候，特别容易去知乎、v2 等论坛摸鱼。 说白了，还是注意力没法长时间集中的问题。 后来同学给安利了「番茄学习法」，我之前虽然也有了解过，但是没有实践。这次到 App Store 中找了个软件下来用了下。大概就是下图的样子： 我今天学习了 4 个番茄，每个番茄是 35 分钟（刚开始是 25 分钟，养成习惯后，注意力集中的时间慢慢增加），每次学习后都会有 8 分钟休息时间。循环往复，半天就过去了。以番茄为计时单位，多个任务可以切换着做，来防止松懈疲惫。 希望这篇心得对你有帮助","link":"/2019-11-25-how-insist-on-learning/"},{"title":"🔝2020，让我们从头来过","text":"随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？ 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计 …… 域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！ 20192019 年十二月份，北方正值最冷的时候，在深圳依然 20 多度短袖出门。这一年，我如愿以偿拿到了 B（bytedance）、A（alibaba）、T（tencent）三家的 Offer。由于是双学位（计算机科学+数学），需要完成 2 篇毕设，只能选择回校专心做毕设。 这一年，既有对技术的狂热追求，也有参与团队项目的合作协同。有幸遇到两位师傅以及团队中的小伙伴，倾囊相助，带我“打怪升级”。有太多感谢的话想对帮助过我的朋友说，有时间会专门写一篇文章。 这篇文章当然不是讲 2019 年的技术之路，而是想谈谈为什么要做 xxoo521.com 这个博客。 没有银弹今年，我开过很多网站应用，vue、react、hexo、vuepress、next、小程序甚至小游戏，渐渐发现没有一种技术是银弹，要在对应场景下选择最适合的“开发工具”。 注意力重新回到在静态网站应用开发上。 之前的xin-tan.com从 hexo 重构到 vuepress，并且基于插件、组件、继承等机制实现了高度定制。它的出发点从建站开始就敲定了：搭建前端知识网络。因此，所有的文章都会被规约到现有网络的某个分类中，逻辑清晰，读者阅读成本低，尤其适合在面试前回顾相应的知识点。 而随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？这是个老生常谈的话题。 以 ReactJS 为例，如果你深入了解过 Diff 的原理，你会发现其中的精髓就是图的节点遍历，并且通过“剪枝”思想降低了时间复杂度。如果你手写过 Promise，你会发现它的本质就是“状态机”。如果你了解 Nodejs 的 Cluster，你会发现它的实现就是“轮询调度”算法。如果了解过 hook 的原理、koa 的设计、上千字段的表格字段联动优化等等这些听起来“高大上”的东西，你会发现其背后是我们常常谈及，却也经常忽略的算法和数据结构的应用。 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计。平日工作中，经常撸码的前端 er 肯定会对 js 越来越熟悉，是一种下意识的“刻意训练”。但不是所有的工作都需要用到一些经典的算法或数据结构，大多数情况下哈希表和数组能解决大多数问题，二叉树、并查集、AVL、回溯剪枝、动态规划等几乎难以遇到。 为了保持对算法和数据结构的应用的“刻意训练”，我重启了吃灰已久的 Leetcode 账号，开始坚持每日刷题（并逐渐上头）。过程中发现优雅的 js 实现少之又少（可能后端同学刷题多一些），Java、c++和 python 都多于 js。本着帮助别人，督促自己的想法，以及算法类文章自带多个标签，所以选定了用 hexo 来建立新站。 xin-tan.com 专注前端，xxoo521.com 专注算法。 从头来过根据谷歌分析给出的数据，xin-tan.com 的月用户稳定在了 5000-7000 ，新开一个站估计会来看的小伙伴会少的可怜。对于爱交流（话多）的我来说，称得上是“从头来过”，我也做好僵尸站的准备了。 前面也有讲过，xin-tan.com搭建的是前端知识网络。所以一直增加文章，尽可能在收归在某篇原来的文章中，最大化地避免水文。xxoo521.com 达到干货满满，还有很长路要走。 算法题做多了，腿也不疼了，腰也不酸了，脑瓜也感觉更加灵光，但是脱发确实是个问题。保证每份代码都是 AC，尽可能用简单话语说明白解题思路以及相关的知识点。快乐学习，一起进步，共同成长。 域名真的好记域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！","link":"/2019-12-19-let-us-restart/"},{"title":"高效交流，欢迎进群","text":"想不明白的问题，别人的几句话就可能点醒。而一个人坚持学习难免开小差，共同交流才更有氛围。 在这里，不仅仅能提升前端工程/算法设计能力，还能遇到更多小伙伴。 群职能 只要坚持，就一定能有所收获。收获不仅仅是提升前端工程/算法设计能力，也可以是认识更多开发者、找到一起做开源项目的小伙伴，这些都会产生更多长远的影响。 最新文章会第一时间同步到群中，欢迎给公众号投稿，或者反馈意见。 找内推可以看昵称（包含公司），建议准备好了再私发简历。 希望大家在群里可以巩固提高前端算法能力，或者认识小伙伴，或者找到内推。 群规定 进群请修改群名片，格式为：[公司/学校]-[昵称]-[特殊说明]，例如：腾讯-心谭-毕业入职，清华-dolly。 友好地咨询交流问题，提出意见，别人可能在忙，有时间请相互帮助下。 禁止讨论和前端/算法无关问题，特别是广告。一次禁言，两次退群，希望大家配合。 微信群 QQ 群","link":"/2019-12-20-contact/"}],"tags":[{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"}],"categories":[{"name":"css系列","slug":"css系列","link":"/categories/css%E7%B3%BB%E5%88%97/"},{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"},{"name":"想法","slug":"想法","link":"/categories/%E6%83%B3%E6%B3%95/"}]}