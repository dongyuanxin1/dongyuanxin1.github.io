{"pages":[],"posts":[{"title":"如何保持保持高效学习？","text":"这是我最近特别想记录的心得，关于「如何保持高效学习」。 在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 这是我最近特别想记录的心得，关于「如何保持高效学习」。 最近在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 制定任务，模拟奖励根据这几个月重新玩「神武」（一款类似梦幻西游的回合制游戏）的感触，我发现这款游戏让人上瘾的点在于：你可以通过做任务/参见活动，获得各种奖励，并且提高人物的属性面板。我天，仔细想了下这不是和自我学习有点相似？ 于是我尝试着给自己制定每周任务，像「实现 promise」、「计算机专业论文算法完成」、「数学专业完成矩阵特征值的 4 中方法编程实现」。 有了任务，怎么模拟奖励呢？游戏给我的奖励是「提高人物属性」，潜意识里就是告诉玩家“你在变强”。思路转化过来就是，模拟的奖励需要让我自己感觉我在变强：）因此模拟的奖励是： 技术面变广，技术栈变深 定期将所学输出文章，方便日后回查，也打造个人 IP 早做完毕设，早回公司，脱离无 💰 生活 番茄学习仔细玩游戏你会发现，游戏的大多数任务和活动，都是玩家 10-20 分钟之间可以完成的。如果一个任务做了 2 小时，任谁都会感觉又累又烦。在学习过程中同样如此，一个学习任务一下午，状态差的时候，特别容易去知乎、v2 等论坛摸鱼。 说白了，还是注意力没法长时间集中的问题。 后来同学给安利了「番茄学习法」，我之前虽然也有了解过，但是没有实践。这次到 App Store 中找了个软件下来用了下。大概就是下图的样子： 我今天学习了 4 个番茄，每个番茄是 35 分钟（刚开始是 25 分钟，养成习惯后，注意力集中的时间慢慢增加），每次学习后都会有 8 分钟休息时间。循环往复，半天就过去了。以番茄为计时单位，多个任务可以切换着做，来防止松懈疲惫。 希望这篇心得对你有帮助","link":"/2019-11-25-how-insist-on-learning/"},{"title":"🔝2020，让我们从头来过","text":"随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？ 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计 …… 域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！ 20192019 年十二月份，北方正值最冷的时候，在深圳依然 20 多度短袖出门。这一年，我如愿以偿拿到了 B（bytedance）、A（alibaba）、T（tencent）三家的 Offer。由于是双学位（计算机科学+数学），需要完成 2 篇毕设，只能选择回校专心做毕设。 这一年，既有对技术的狂热追求，也有参与团队项目的合作协同。有幸遇到两位师傅以及团队中的小伙伴，倾囊相助，带我“打怪升级”。有太多感谢的话想对帮助过我的朋友说，有时间会专门写一篇文章。 这篇文章当然不是讲 2019 年的技术之路，而是想谈谈为什么要做 xxoo521.com 这个博客。 没有银弹今年，我开过很多网站应用，vue、react、hexo、vuepress、next、小程序甚至小游戏，渐渐发现没有一种技术是银弹，要在对应场景下选择最适合的“开发工具”。 注意力重新回到在静态网站应用开发上。 之前的xin-tan.com从 hexo 重构到 vuepress，并且基于插件、组件、继承等机制实现了高度定制。它的出发点从建站开始就敲定了：搭建前端知识网络。因此，所有的文章都会被规约到现有网络的某个分类中，逻辑清晰，读者阅读成本低，尤其适合在面试前回顾相应的知识点。 而随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？这是个老生常谈的话题。 以 ReactJS 为例，如果你深入了解过 Diff 的原理，你会发现其中的精髓就是图的节点遍历，并且通过“剪枝”思想降低了时间复杂度。如果你手写过 Promise，你会发现它的本质就是“状态机”。如果你了解 Nodejs 的 Cluster，你会发现它的实现就是“轮询调度”算法。如果了解过 hook 的原理、koa 的设计、上千字段的表格字段联动优化等等这些听起来“高大上”的东西，你会发现其背后是我们常常谈及，却也经常忽略的算法和数据结构的应用。 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计。平日工作中，经常撸码的前端 er 肯定会对 js 越来越熟悉，是一种下意识的“刻意训练”。但不是所有的工作都需要用到一些经典的算法或数据结构，大多数情况下哈希表和数组能解决大多数问题，二叉树、并查集、AVL、回溯剪枝、动态规划等几乎难以遇到。 为了保持对算法和数据结构的应用的“刻意训练”，我重启了吃灰已久的 Leetcode 账号，开始坚持每日刷题（并逐渐上头）。过程中发现优雅的 js 实现少之又少（可能后端同学刷题多一些），Java、c++和 python 都多于 js。本着帮助别人，督促自己的想法，以及算法类文章自带多个标签，所以选定了用 hexo 来建立新站。 xin-tan.com 专注前端，xxoo521.com 专注算法。 从头来过根据谷歌分析给出的数据，xin-tan.com 的月用户稳定在了 5000-7000 ，新开一个站估计会来看的小伙伴会少的可怜。对于爱交流（话多）的我来说，称得上是“从头来过”，我也做好僵尸站的准备了。 前面也有讲过，xin-tan.com搭建的是前端知识网络。所以一直增加文章，尽可能在收归在某篇原来的文章中，最大化地避免水文。xxoo521.com 达到干货满满，还有很长路要走。 算法题做多了，腿也不疼了，腰也不酸了，脑瓜也感觉更加灵光，但是脱发确实是个问题。保证每份代码都是 AC，尽可能用简单话语说明白解题思路以及相关的知识点。快乐学习，一起进步，共同成长。 域名真的好记域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！","link":"/2019-12-19-let-us-restart/"},{"title":"高效交流，欢迎进群","text":"想不明白的问题，别人的几句话就可能点醒。而一个人坚持学习难免开小差，共同交流才更有氛围。 在这里，不仅仅能提升前端工程/算法设计能力，还能遇到更多小伙伴。 群职能 只要坚持，就一定能有所收获。收获不仅仅是提升前端工程/算法设计能力，也可以是认识更多开发者、找到一起做开源项目的小伙伴，这些都会产生更多长远的影响。 最新文章会第一时间同步到群中，欢迎给公众号投稿，或者反馈意见。 找内推可以看昵称（包含公司），建议准备好了再私发简历。 希望大家在群里可以巩固提高前端算法能力，或者认识小伙伴，或者找到内推。 群规定 进群请修改群名片，格式为：[公司/学校]-[昵称]-[特殊说明]，例如：腾讯-心谭-毕业入职，清华-dolly。 友好地咨询交流问题，提出意见，别人可能在忙，有时间请相互帮助下。 禁止讨论和前端/算法无关问题，特别是广告。一次禁言，两次退群，希望大家配合。 微信群 QQ 群","link":"/2019-12-20-contact/"},{"title":"剑指offer - 替换空格 - JavaScript","text":"题目描述: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 解法 1：正则表达式第一反应肯定正则表达式，在真正项目中，肯定也会选用正则来做匹配和替换。 123456789// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { return str.replace(/ /g, \"%20\");} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：双指针因为字符串是不可变的，所以如果直接采用从头到尾遍历原字符串检查空格，并且做替换。那么每次检查到空格后，都需要重新生成字符串。整个过程时间复杂度是 O(N^2)。 优化的关键：提前计算替换后的字符串的长度，避免每次都对字符串做改动。 整体思路如下： 遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度 准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串 i 从头开始遍历原字符串 str[i]是非空格，那么将 i 指向的字符放入新字符串的 j 位置。i 和 j 都增加 1。 str[i]是空格，那么 j 指向的位置依次填入%20。i 增加 1，j 增加 3。 时间复杂度是 O(N)。因为需要对新字符串开辟容器，空间复杂度是 O(N)。 12345678910111213141516171819202122232425262728293031323334353637// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { if (!str || !str.length) { return \"\"; } let emptyNum = 0, chNum = 0; for (let i = 0; i &lt; str.length; ++i) { if (str[i] === \" \") { ++emptyNum; } else { ++chNum; } } const length = emptyNum * 2 + chNum; const chs = new Array(length); // i 是新字符串的下标 // j 是原字符串的下标 for (let i = 0, j = 0; j &lt; str.length; ++j) { if (str[j] === \" \") { chs[i++] = \"%\"; chs[i++] = \"2\"; chs[i++] = \"0\"; } else { chs[i++] = str[j]; } } return chs.join(\"\");}","link":"/2019-12-19-ti-huan-kong-ge/"},{"title":"剑指offer - 二维数组中的查找 - JavaScript","text":"题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法 1：暴力法遍历数组中的所有元素，找到是否存在。 时间复杂度是 O(N^2)，空间复杂度是 O(1) 12345678910111213141516171819202122// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; for (let i = 0; i &lt; rowNum; i++) { for (let j = 0; j &lt; colNum; j++) { if (array[i][j] === target) return true; } } return false;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：观察数组规律按照题目要求，数组的特点是：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。考虑以下数组： 1231 2 34 5 67 8 9 在其中寻找 5 是否存在。过程如下： 从右上角开始遍历 当前元素小于目标元素(3 &lt; 5)，根据数组特点，当前行中最大元素也小于目标元素，因此进入下一行 当前元素大于目标元素(6 &gt; 5)，根据数组特点，行数不变，尝试向前一列查找 找到 5 代码如下： 1234567891011121314151617181920212223242526272829303132// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; if (!colNum) { return false; } let row = 0, col = colNum - 1; while (row &lt; rowNum &amp;&amp; col &gt;= 0) { if (array[row][col] === target) { return true; } else if (array[row][col] &gt; target) { --col; } else { ++row; } } return false;} 时间复杂度是 O(M+N)，空间复杂度是 O(1)。其中 M 和 N 分别代表行数和列数。","link":"/2019-12-19-er-wei-shu-zu-cha-zhao/"},{"title":"剑指offer - 从尾到头打印链表 - JavaScript","text":"题目描述：输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 题目描述输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 解法 1: 栈题目要求的是从尾到头。这种“后进先出”的访问顺序，自然想到了用栈。 时间复杂度 O(N)，空间复杂度 O(N)。 123456789101112131415161718192021222324252627// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//*function ListNode(x){ this.val = x; this.next = null;}*//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } const reverse = []; while (stack.length) { reverse.push(stack.pop()); } return reverse;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 发现后半段出栈的逻辑，其实就是将数组reverse反转。因此，借助 javascript 的 api，更优雅的写法如下： 1234567891011121314151617// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } return stack.reverse();}","link":"/2019-12-21-da-yin-lian-biao/"},{"title":"剑指offer - 重建二叉树 - JavaScript","text":"题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解法 1: 递归首先前序/后序遍历 + 中序遍历可以重建二叉树。题目考察的就是前序+中序来重建二叉树，后序+中序的思路是类似的。 例子与思路假设有二叉树如下： 12345 1 / \\ 2 3 / \\4 5 它的前序遍历的顺序是：1 2 4 5 3。中序遍历的顺序是：4 2 5 1 3 因为前序遍历的第一个元素就是当前二叉树的根节点。那么，这个值就可以将中序遍历分成 2 个部分。在以上面的例子，中序遍历就被分成了 4 2 5 和 3 两个部分。4 2 5就是左子树，3就是右子树。 最后，根据左右子树，继续递归即可。 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 代码实现123456789101112131415161718192021222324252627282930313233// ac地址：https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6// 原文地址：https://xxoo521.com/2019-12-21-re-construct-btree//* function TreeNode(x) { this.val = x; this.left = null; this.right = null;} *//** * @param {TreeNode} pre * @param {TreeNode} vin * @return {TreeNode} */function reConstructBinaryTree(pre, vin) { if (!pre.length || !vin.length) { return null; } const rootVal = pre[0]; const node = new TreeNode(rootVal); let i = 0; // i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数 for (; i &lt; vin.length; ++i) { if (vin[i] === rootVal) { break; } } node.left = reConstructBinaryTree(pre.slice(1, i + 1), vin.slice(0, i)); node.right = reConstructBinaryTree(pre.slice(i + 1), vin.slice(i + 1)); return node;}","link":"/2019-12-21-re-construct-btree/"}],"tags":[{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"}],"categories":[{"name":"想法","slug":"想法","link":"/categories/%E6%83%B3%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"}]}