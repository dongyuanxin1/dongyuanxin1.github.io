{"pages":[],"posts":[{"title":"🔝2020，让我们从头来过","text":"随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？ 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计 …… 域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！ 20192019 年十二月份，北方正值最冷的时候，在深圳依然 20 多度短袖出门。这一年，我如愿以偿拿到了 B（bytedance）、A（alibaba）、T（tencent）三家的 Offer。由于是双学位（计算机科学+数学），需要完成 2 篇毕设，只能选择回校专心做毕设。 这一年，既有对技术的狂热追求，也有参与团队项目的合作协同。有幸遇到两位师傅以及团队中的小伙伴，倾囊相助，带我“打怪升级”。有太多感谢的话想对帮助过我的朋友说，有时间会专门写一篇文章。 这篇文章当然不是讲 2019 年的技术之路，而是想谈谈为什么要做 xxoo521.com 这个博客。 没有银弹今年，我开过很多网站应用，vue、react、hexo、vuepress、next、小程序甚至小游戏，渐渐发现没有一种技术是银弹，要在对应场景下选择最适合的“开发工具”。 注意力重新回到在静态网站应用开发上。 之前的xin-tan.com从 hexo 重构到 vuepress，并且基于插件、组件、继承等机制实现了高度定制。它的出发点从建站开始就敲定了：搭建前端知识网络。因此，所有的文章都会被规约到现有网络的某个分类中，逻辑清晰，读者阅读成本低，尤其适合在面试前回顾相应的知识点。 而随着前端技术的火速发展，越来越多的新技术映入眼帘。每个人的精力都是有限的，如何在面对新技术的时候能触类旁通、快速学习？这是个老生常谈的话题。 以 ReactJS 为例，如果你深入了解过 Diff 的原理，你会发现其中的精髓就是图的节点遍历，并且通过“剪枝”思想降低了时间复杂度。如果你手写过 Promise，你会发现它的本质就是“状态机”。如果你了解 Nodejs 的 Cluster，你会发现它的实现就是“轮询调度”算法。如果了解过 hook 的原理、koa 的设计、上千字段的表格字段联动优化等等这些听起来“高大上”的东西，你会发现其背后是我们常常谈及，却也经常忽略的算法和数据结构的应用。 对于新的技术，扎实的 JS 基础能帮助我们快速上手，而对算法和数据结构的熟悉能加快理解新技术的原理设计。平日工作中，经常撸码的前端 er 肯定会对 js 越来越熟悉，是一种下意识的“刻意训练”。但不是所有的工作都需要用到一些经典的算法或数据结构，大多数情况下哈希表和数组能解决大多数问题，二叉树、并查集、AVL、回溯剪枝、动态规划等几乎难以遇到。 为了保持对算法和数据结构的应用的“刻意训练”，我重启了吃灰已久的 Leetcode 账号，开始坚持每日刷题（并逐渐上头）。过程中发现优雅的 js 实现少之又少（可能后端同学刷题多一些），Java、c++和 python 都多于 js。本着帮助别人，督促自己的想法，以及算法类文章自带多个标签，所以选定了用 hexo 来建立新站。 xin-tan.com 专注前端，xxoo521.com 专注算法。 从头来过根据谷歌分析给出的数据，xin-tan.com 的月用户稳定在了 5000-7000 ，新开一个站估计会来看的小伙伴会少的可怜。对于爱交流（话多）的我来说，称得上是“从头来过”，我也做好僵尸站的准备了。 前面也有讲过，xin-tan.com搭建的是前端知识网络。所以一直增加文章，尽可能在收归在某篇原来的文章中，最大化地避免水文。xxoo521.com 达到干货满满，还有很长路要走。 算法题做多了，腿也不疼了，腰也不酸了，脑瓜也感觉更加灵光，但是脱发确实是个问题。保证每份代码都是 AC，尽可能用简单话语说明白解题思路以及相关的知识点。快乐学习，一起进步，共同成长。 域名真的好记域名 xxoo521.com 只是噱头，最重要的是好记，减少记忆成本。希望能在学习过程中放松一下，博君一笑！","link":"/2019-12-19-let-us-restart/"},{"title":"剑指offer - 矩阵覆盖 - JavaScript","text":"题目描述:我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题目描述我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 解法 1: 斐波那契数列这题和“青蛙跳台阶”类似，也是斐波那契数列的变形。 假设覆盖2*n矩形有 f(n) 种方法。那么这个2*n的矩形可能由2*(n-1)和2*(n-2)的矩形直接一步变化而来。如下图所示： 因此 f(n) = f(n - 1) + f(n - 2)。 代码如下： 123456789101112131415161718192021222324252627// 原文地址：https://xxoo521.com/2019-12-30-ju-zhen-fu-gai/// ac地址：https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6/** * @param {number} number * @return {number} */function rectCover(number) { if (number === 0) { return 0; } const cache = { 0: 0, 1: 1 }; return __rectCover(number + 1); function __rectCover(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __rectCover(n - 1) + __rectCover(n - 2); return cache[n]; }} 斐波那契相关题目 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 斐波那契数列：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 青蛙跳台阶：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/","link":"/2019-12-30-ju-zhen-fu-gai/"},{"title":"剑指offer - 变态跳台阶 - JavaScript","text":"题目描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 解法 1: 公式推导假设跳 n 级台阶的跳法数量是 f(n)个。 那么根据题意，青蛙可能从 n-1 级直接跳上来，也可能从 n-2 级直接跳上来，依次类推：f(n) = f(n - 1) + f(n - 2) + ... + f(1) 同理：f(n - 1) = f(n - 2) + f(n - 3) + ... + f(1) 所以，将公式 1 中的f(n - 2) + f(n - 3) + ... + f(1)替换为f(n - 1)。公式 1 变为：f(n) = f(n - 1) + f(n - 1) = f(n - 1) * 2 （公式 3） 同理：f(n - 1) = f(n - 2) + f(n - 2) = f(n - 2) * 2（公式 4） 结合公式 3 和公式 4: f(n) = f(n - 2) * 2 * 2。因此可以推出：f(n) = 2^(n - 1) 代码如下： 12345678910// 原文地址：https://xxoo521.com/2019-12-27-bian-tai-tiao-tai-jie/// ac地址：https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387/** * @param {number} number * @return {number} */function jumpFloorII(number) { return Math.pow(2, number - 1);} 相关题目 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 斐波那契数列：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 青蛙跳台阶：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/ 矩阵覆盖:https://xxoo521.com/2019-12-30-ju-zhen-fu-gai/","link":"/2019-12-27-bian-tai-tiao-tai-jie/"},{"title":"剑指offer - 青蛙跳台阶 - JavaScript","text":"题目描述: 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解法 1: 斐波那契数列这题其实就是在求斐波那契数列。理解起来也很简单。假设跳到 n 级台阶有 f(n)种方法。根据题目，青蛙在跳上 n 级时有 2 种方法： 从 n - 1 级跳 1 级上来 从 n - 2 级跳 2 级上来 青蛙跳到 n- 1 级有 f(n-1)种方法，跳到 n- 2 级有 f(n-2)种方法。所以 f(n) = f(n - 1) + f(n - 2)。这就是斐波那契数列的定义式。 需要注意的是，它和斐波那契下标不是完全对应。比如跳上 2 级，有 2 种方法。所以跳上 n 级不是 f(n)，而是 f(n + 1)。 12345678910111213141516171819// 原文地址：https://xxoo521.com/2019-12-26-qing-wa-tiao-tai-jie/// ac地址：https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4function jumpFloor(n) { const cache = { 0: 0, 1: 1 }; return __jumpFloor(n + 1); // 注意下标 function __jumpFloor(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __jumpFloor(n - 1) + __jumpFloor(n - 2); return cache[n]; }} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 更多解法关于斐波那契还有循环写法，以及备忘录模式的其他优点。具体请看：https://xxoo521.com/2019-12-25-fei-bo-na-qi/。","link":"/2019-12-26-qing-wa-tiao-tai-jie/"},{"title":"剑指offer - 斐波那契数列 - JavaScript","text":"题目描述：大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39。 题目描述大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。n&lt;=39。 解法 1: 数学定义根据数学定义：f(n) = f(n - 1) + f(n - 2)。最初始情况是f(0) = 0和f(1) = 1。 因此直接循环更新即可。时间复杂度 O(N)，空间复杂度 O(1)。 12345678910111213141516171819202122232425// 原文地址：https://xxoo521.com/2019-12-25-fei-bo-na-qi/// ac地址：https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3/** * @param {number} n * @return {number} */function Fibonacci(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } let a = 0, b = 1; for (let i = 2; i &lt; n; ++i) { let c = a + b; a = b; b = c; } return a + b;} 解法 2: 递归 + 动态规划根据数学定义：f(n) = f(n - 1) + f(n - 2)，代码可以实现为递归形式。 但是以 f(5)为例，它的过程如下： f(5) = f(4) + f(3) f(4) = f(3) + f(2) f(3) = f(2) + f(1) …省略 注意在第 2 步和第 3 步中，我们计算了 2 次 f(3)的值。当要求的 n 越大的时候，重复计算就会越多，时间复杂度就会越高。 在动态规划的一种做法中，可以借助“备忘录”来实现结果的缓存，避免重复计算。 代码如下，时间复杂度是 O(N)，空间复杂度是 O(1)。 123456789101112131415161718192021222324252627// 原文地址：https://xxoo521.com/2019-12-25-fei-bo-na-qi/// ac地址：https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3/** * @param {number} n * @return {number} */function Fibonacci(n) { const cache = { 0: 0, 1: 1 }; return __Fibonacci(n); /** * @param {number} n * @return {number} */ function __Fibonacci(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = __Fibonacci(n - 1) + __Fibonacci(n - 2); return cache[n]; }} “备忘录”的其他优点 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 虽然备忘录用了 O(N)的空间。但是重复计算同个 f(n)的结果时候，时间复杂度是 O(1)。比如之前调用过一次Fibonacci(10)，那么 f(10)的结果就缓存在了 cache 中。再次调用函数，直接从缓存读取即可。 同样地，当 n &lt; 10 时候，结果都是从 cache 中直接读取，时间复杂度均是 O(1)。 再推广，当计算 f(20)的时候，n &lt; 10 的结果都计算完了，不需要重复计算。效率是高于第一种循环写法的调用。 总结：备忘录缓存了计算结果，避免了多次调用时的重复计算。","link":"/2019-12-25-fei-bo-na-qi/"},{"title":"剑指offer - 旋转数组的最小数字 - JavaScript","text":"题目描述:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 解法 1:暴力法遍历一次，直接找到比较出最小的数字。 时间复杂度是 O(N)，空间复杂度是 O(1)。 1234567891011121314// 原文地址：https://xxoo521.com/2019-12-24-xuan-zhuan-shu-zu/// ac地址：https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba/** * @param {number[]} rotateArray */function minNumberInRotateArray(rotateArray) { const length = rotateArray.length; if (!length) { return 0; } return Math.min(...rotateArray);} 解法 2: 二分查找 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 看到这种题目，正确做法基本上都是需要使用二分查找。 对于这种变形的二分查找的考察，解决思路主要都是：观察 left、mid、right 三个指针对应的元素的大小关系，然后移动指针。 具体的解决方法主要是：多写几个例子，然后观察如何移动。 举几个例子来推导解题细节（请记住题干的数组有序、某个点旋转这两个条件）： arr[left] &lt; arr[right]: 直接返回arr[left]。例如：1 2 3 4 5 arr[left] &lt; arr[mid]: 说明从数组下标范围为[left, right]的元素是递增的，此时最小值只可能出现在[mid + 1, length)范围内。例如:4 5 1 2 3 arr[mid] &lt; arr[right]: 说明从数组下标范围为[mid, right]的元素是递增的，此时最小值只可能出现在[left, mid] 范围内。注意，这里不能跳过下标mid。例如：3 3 3 4 5 其他情况，此时arr[mid] = arr[right] = arr[left]: 移动 left，缩小范围即可。例如：1 1 1 0 1 1234567891011121314151617181920212223242526272829303132333435// 原文地址：https://xxoo521.com/2019-12-24-xuan-zhuan-shu-zu/// ac地址：https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01bafunction minNumberInRotateArray(rotateArray) { const length = rotateArray.length; if (!length) { return 0; } let left = 0, right = length - 1; while (left &lt; right) { let mid = Math.floor((left + right) / 2); // 子数组有序 if (rotateArray[left] &lt; rotateArray[right]) { return rotateArray[left]; } // 左子数组有序，最小值在右边 // 那么mid肯定不可能是最小值（因为rotateArray[mid]大于rotateArray[left]） if (rotateArray[left] &lt; rotateArray[mid]) { left = mid + 1; // 右子数组有序，最小值在左边 // 这里right=mid因为最小值可能就是rotateArray[mid] } else if (rotateArray[mid] &lt; rotateArray[right]) { right = mid; } else { // 无法判断，缩小下范围 ++left; } } return rotateArray[left];}","link":"/2019-12-24-xuan-zhuan-shu-zu/"},{"title":"剑指offer - 用两个栈(队列)实现队列(栈) - JavaScript","text":"题目描述：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 拓展思考：如何用两个队列实现一个栈？ 题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 解法 1: 利用栈的特性栈的特性是：后入先出。根据题目提示，使用 2 个栈即可。一个栈inStack用来存储插入队列的数据，一个栈outStack用来从队列中取出数据。 算法分为入队和出队过程。 入队过程：将元素放入 inStack 中。 出队过程： outStack 不为空：弹出元素 outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出） 时间复杂度是 O(N)，空间复杂度是 O(N)。 12345678910111213141516171819// 原文地址：https://xxoo521.com/2019-12-23-zhan-shi-xian-dui-lie/// ac地址：https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6const inStack = [];const outStack = [];function push(node) { inStack.push(node);}function pop() { if (outStack.length) { return outStack.pop(); } else { while (inStack.length) { outStack.push(inStack.pop()); } return outStack.pop(); }} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 拓展思考：用两个队列实现一个栈类似地，用两个队列也可以实现一个栈。但由于队列是先入先出，无论怎么倒换，都不可能逆序队列。所以处理思路并不一样。 准备两个队列q1和q2。算法过程分为入栈和出栈。 入栈过程： q1 为空，放入 q2 q2 为空，放入 q1 均为空，默认放入 q1 出栈过程： q1 为空： 依次取出 q2 中的元素（除了最后一个），并且放入 q1 中 取出 q2 中的最后一个元素，返回结果 q2 为空： 依次取出 q1 中的元素（除了最后一个），并且放入 q2 中 取出 q1 中的最后一个元素，返回结果 时间复杂度是 O(N)，空间复杂度是 O(N)。","link":"/2019-12-23-zhan-shi-xian-dui-lie/"},{"title":"剑指offer - 重建二叉树 - JavaScript","text":"题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解法 1: 递归首先前序/后序遍历 + 中序遍历可以重建二叉树。题目考察的就是前序+中序来重建二叉树，后序+中序的思路是类似的。 例子与思路假设有二叉树如下： 12345 1 / \\ 2 3 / \\4 5 它的前序遍历的顺序是：1 2 4 5 3。中序遍历的顺序是：4 2 5 1 3 因为前序遍历的第一个元素就是当前二叉树的根节点。那么，这个值就可以将中序遍历分成 2 个部分。在以上面的例子，中序遍历就被分成了 4 2 5 和 3 两个部分。4 2 5就是左子树，3就是右子树。 最后，根据左右子树，继续递归即可。 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 代码实现123456789101112131415161718192021222324252627282930313233// ac地址：https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6// 原文地址：https://xxoo521.com/2019-12-21-re-construct-btree//* function TreeNode(x) { this.val = x; this.left = null; this.right = null;} *//** * @param {TreeNode} pre * @param {TreeNode} vin * @return {TreeNode} */function reConstructBinaryTree(pre, vin) { if (!pre.length || !vin.length) { return null; } const rootVal = pre[0]; const node = new TreeNode(rootVal); let i = 0; // i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数 for (; i &lt; vin.length; ++i) { if (vin[i] === rootVal) { break; } } node.left = reConstructBinaryTree(pre.slice(1, i + 1), vin.slice(0, i)); node.right = reConstructBinaryTree(pre.slice(i + 1), vin.slice(i + 1)); return node;}","link":"/2019-12-21-re-construct-btree/"},{"title":"剑指offer - 从尾到头打印链表 - JavaScript","text":"题目描述：输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 题目描述输入一个链表，按链表从尾到头的顺序返回一个 ArrayList。 解法 1: 栈题目要求的是从尾到头。这种“后进先出”的访问顺序，自然想到了用栈。 时间复杂度 O(N)，空间复杂度 O(N)。 123456789101112131415161718192021222324252627// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//*function ListNode(x){ this.val = x; this.next = null;}*//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } const reverse = []; while (stack.length) { reverse.push(stack.pop()); } return reverse;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 发现后半段出栈的逻辑，其实就是将数组reverse反转。因此，借助 javascript 的 api，更优雅的写法如下： 1234567891011121314151617// ac地址：https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035// 原文地址：https://xxoo521.com/2019-12-21-da-yin-lian-biao//** * @param {ListNode} head * @return {any[]} */function printListFromTailToHead(head) { const stack = []; let node = head; while (node) { stack.push(node.val); node = node.next; } return stack.reverse();}","link":"/2019-12-21-da-yin-lian-biao/"},{"title":"高效交流，欢迎进群","text":"想不明白的问题，别人的几句话就可能点醒。而一个人坚持学习难免开小差，共同交流才更有氛围。 在这里，不仅仅能提升前端工程/算法设计能力，还能遇到更多小伙伴。 群职能 只要坚持，就一定能有所收获。收获不仅仅是提升前端工程/算法设计能力，也可以是认识更多开发者、找到一起做开源项目的小伙伴，这些都会产生更多长远的影响。 最新文章会第一时间同步到群中，欢迎给公众号投稿，或者反馈意见。 找内推可以看昵称（包含公司），建议准备好了再私发简历。 希望大家在群里可以巩固提高前端算法能力，或者认识小伙伴，或者找到内推。 群规定 进群请修改群名片，格式为：[公司/学校]-[昵称]-[特殊说明]，例如：腾讯-心谭-毕业入职，清华-dolly。 友好地咨询交流问题，提出意见，别人可能在忙，有时间请相互帮助下。 禁止讨论和前端/算法无关问题，特别是广告。一次禁言，两次退群，希望大家配合。 微信群 QQ 群","link":"/2019-12-20-contact/"},{"title":"剑指offer - 二维数组中的查找 - JavaScript","text":"题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法 1：暴力法遍历数组中的所有元素，找到是否存在。 时间复杂度是 O(N^2)，空间复杂度是 O(1) 12345678910111213141516171819202122// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; for (let i = 0; i &lt; rowNum; i++) { for (let j = 0; j &lt; colNum; j++) { if (array[i][j] === target) return true; } } return false;} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：观察数组规律按照题目要求，数组的特点是：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。考虑以下数组： 1231 2 34 5 67 8 9 在其中寻找 5 是否存在。过程如下： 从右上角开始遍历 当前元素小于目标元素(3 &lt; 5)，根据数组特点，当前行中最大元素也小于目标元素，因此进入下一行 当前元素大于目标元素(6 &gt; 5)，根据数组特点，行数不变，尝试向前一列查找 找到 5 代码如下： 1234567891011121314151617181920212223242526272829303132// ac地址：https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e// 原文地址：https://xxoo521.com/2019-12-19-er-wei-shu-zu-cha-zhao//** * * @param {number} target * @param {number[][]} array */function Find(target, array) { const rowNum = array.length; if (!rowNum) { return false; } const colNum = array[0].length; if (!colNum) { return false; } let row = 0, col = colNum - 1; while (row &lt; rowNum &amp;&amp; col &gt;= 0) { if (array[row][col] === target) { return true; } else if (array[row][col] &gt; target) { --col; } else { ++row; } } return false;} 时间复杂度是 O(M+N)，空间复杂度是 O(1)。其中 M 和 N 分别代表行数和列数。","link":"/2019-12-19-er-wei-shu-zu-cha-zhao/"},{"title":"剑指offer - 替换空格 - JavaScript","text":"题目描述: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 解法 1：正则表达式第一反应肯定正则表达式，在真正项目中，肯定也会选用正则来做匹配和替换。 123456789// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { return str.replace(/ /g, \"%20\");} 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：「微信公众号：心谭博客」| xxoo521.com | GitHub 解法 2：双指针因为字符串是不可变的，所以如果直接采用从头到尾遍历原字符串检查空格，并且做替换。那么每次检查到空格后，都需要重新生成字符串。整个过程时间复杂度是 O(N^2)。 优化的关键：提前计算替换后的字符串的长度，避免每次都对字符串做改动。 整体思路如下： 遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度 准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串 i 从头开始遍历原字符串 str[i]是非空格，那么将 i 指向的字符放入新字符串的 j 位置。i 和 j 都增加 1。 str[i]是空格，那么 j 指向的位置依次填入%20。i 增加 1，j 增加 3。 时间复杂度是 O(N)。因为需要对新字符串开辟容器，空间复杂度是 O(N)。 12345678910111213141516171819202122232425262728293031323334353637// ac地址：https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423// 原文地址：https://xxoo521.com/2019-12-19-ti-huan-kong-ge//** * @param {string} str * @return {string} */function replaceSpace(str) { if (!str || !str.length) { return \"\"; } let emptyNum = 0, chNum = 0; for (let i = 0; i &lt; str.length; ++i) { if (str[i] === \" \") { ++emptyNum; } else { ++chNum; } } const length = emptyNum * 2 + chNum; const chs = new Array(length); // i 是新字符串的下标 // j 是原字符串的下标 for (let i = 0, j = 0; j &lt; str.length; ++j) { if (str[j] === \" \") { chs[i++] = \"%\"; chs[i++] = \"2\"; chs[i++] = \"0\"; } else { chs[i++] = str[j]; } } return chs.join(\"\");}","link":"/2019-12-19-ti-huan-kong-ge/"},{"title":"如何保持保持高效学习？","text":"这是我最近特别想记录的心得，关于「如何保持高效学习」。 在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 这是我最近特别想记录的心得，关于「如何保持高效学习」。 最近在从公司离职后回校作毕业设计的很长一段时间内，我都在不停地滑水。所谓学习 1 小时，摸鱼 2 小时。除了坚持每周三次的健身，自己给自己制定的学习任务，双 11 囤下来书，都是进展缓慢。 不像在公司那样，周围同事都很努力，到处弥漫着积极上进的氛围。学校里面大多数时间是自己独自一人在搞事情，没有监督，没有比较，自然严重缺乏动力。 所以，我意识到确实是要作出一些改变了。 制定任务，模拟奖励根据这几个月重新玩「神武」（一款类似梦幻西游的回合制游戏）的感触，我发现这款游戏让人上瘾的点在于：你可以通过做任务/参见活动，获得各种奖励，并且提高人物的属性面板。我天，仔细想了下这不是和自我学习有点相似？ 于是我尝试着给自己制定每周任务，像「实现 promise」、「计算机专业论文算法完成」、「数学专业完成矩阵特征值的 4 中方法编程实现」。 有了任务，怎么模拟奖励呢？游戏给我的奖励是「提高人物属性」，潜意识里就是告诉玩家“你在变强”。思路转化过来就是，模拟的奖励需要让我自己感觉我在变强：）因此模拟的奖励是： 技术面变广，技术栈变深 定期将所学输出文章，方便日后回查，也打造个人 IP 早做完毕设，早回公司，脱离无 💰 生活 番茄学习仔细玩游戏你会发现，游戏的大多数任务和活动，都是玩家 10-20 分钟之间可以完成的。如果一个任务做了 2 小时，任谁都会感觉又累又烦。在学习过程中同样如此，一个学习任务一下午，状态差的时候，特别容易去知乎、v2 等论坛摸鱼。 说白了，还是注意力没法长时间集中的问题。 后来同学给安利了「番茄学习法」，我之前虽然也有了解过，但是没有实践。这次到 App Store 中找了个软件下来用了下。大概就是下图的样子： 我今天学习了 4 个番茄，每个番茄是 35 分钟（刚开始是 25 分钟，养成习惯后，注意力集中的时间慢慢增加），每次学习后都会有 8 分钟休息时间。循环往复，半天就过去了。以番茄为计时单位，多个任务可以切换着做，来防止松懈疲惫。 希望这篇心得对你有帮助","link":"/2019-11-25-how-insist-on-learning/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"}],"categories":[{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"},{"name":"想法","slug":"想法","link":"/categories/%E6%83%B3%E6%B3%95/"}]}